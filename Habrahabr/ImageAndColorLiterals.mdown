Работа с UIImage и UIColor из кода была не слишком удобной, потому что трудно представить себе цвет `UIColor(red: 0.2, green: 0.4, blue: 0.6, alpha: 1)` или `UIImage(named: "pattern25")`, если ты не дизайнер, конечно.

Для меня было чудом то, что Apple сделали в последних версиях Playground, а именно 
-  Возможность указывать цвет, выбирая из палитры цветов:

![image](https://habrastorage.org/files/eca/916/12b/eca91612b23946c68a6ba01bf6fb959e.png)

 -  Возможность выбирать изображение из тех, что находятся в ресурсах:

![image](https://habrastorage.org/files/b32/aad/0f3/b32aad0f31d540d8af7ad78c15b471a4.png)

Цвет представлен очень наглядно и при клике на него, можно узнать какие значения RGBA он имеет и подтюнить его по необходимости.

Миниатюры картинок тоже выглядят гораздо нагляднее, чем просто названия ресурсов. К тому же инициализируя UIImage при помощи failable initializer `init(named: String) -> UIImage?` мы рискуем получить `nil`, неправильно указав имя ресурса. Литералы же всегда возвращают значение.
<cut />
Недавно, копаясь в настройках замечательного линтера [SwiftLint](https://github.com/realm/SwiftLint), я обнаружил, что в нем есть необязательное правило `object_literal`, которое требует, чтобы цвета и картинки указывались из кода при помощи литералов. Неужели, подумал я, блага PlayGround стали доступны и в Xcode? Оказалось, что это правда. Правда, которая чудом прошла мимо меня и, возможно, мимо многих разработчиков. Поэтому, думаю, будет полезным поделиться своим маленьким открытием с общественностью.

Оказывается, задавая переменную типа UIColor в коде, мы можем начать писать _color_

![image](https://habrastorage.org/files/e7f/057/c07/e7f057c07be8498b99f1c41bc8c43153.png)

И, если мы выберем `Color Literal`, появится палитра выбора цветов и можно будет, к примеру, указать cgColor так:

![image](https://habrastorage.org/files/643/836/1a1/6438361a149540c69f9ce937fdcf13e6.png)

С картинками та же история, можно писать _image_

![image](https://habrastorage.org/files/974/9a0/d1c/9749a0d1c5da463ab3b5f2c27242a751.png)

и затем выбирать из галереи миниатюр картинок, или, если мы знаем название картинки можно просто начать писать это название и Xcode предложит варианты картинок из ассетов, в которых встречается вводимое название. В итоге мы получим такую строку:

![image](https://habrastorage.org/files/084/36d/209/08436d209080448596ad34af693d54da.png)

В коде создается невидимая для нас строка `#imageLiteral(resourceName: "ocelot.jpg")`, которая заменяется картинкой и названием ресурса, но если мы начнем набирать эту строку вручную, то добьемся аналогичного эффекта.

## Заключение

Код в котором цвета и картинки представлены наглядно, выглядит очень хорошо и лаконично. Кроме того использование литералов картинок позволяет сразу заметить где что-то пошло не так. Если мы, к примеру, удалим нашего оцелота из ассетов, то код станет выглядеть так:

![image](https://habrastorage.org/files/ed4/e3e/626/ed4e3e6264ea4827b6ec9762c1f728bd.png)

И мы сможем вернуть недостающего котика в наше приложение еще до начала компиляции. Чем, вероятно сэкономим кучу времени при тестировании.

Подробнее об этом можно посмотреть в сессии WWDC 2016 [Using and Extending the Xcode Source Editor](https://developer.apple.com/videos/play/wwdc2016/414/)